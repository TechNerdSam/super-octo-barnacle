<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bataille Navale 3D Ultra</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0F172A; /* slate-900 */
            color: #F1F5F9; /* slate-100 */
            margin: 0;
            overflow: hidden;
        }
        #game-canvas {
            position: fixed;
            top: 0;
            left: 0;
            outline: none;
        }
        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
        }
        .ui-panel {
            background-color: rgba(15, 23, 42, 0.7); /* slate-900 avec transparence */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(51, 65, 85, 0.5); /* slate-700 */
            border-radius: 1rem;
            padding: 1rem 2rem;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            pointer-events: auto;
        }
        .control-button {
            transition: all 0.2s ease;
            transform: scale(1);
        }
        .control-button:hover:not(:disabled) {
            transform: scale(1.05);
            filter: brightness(1.1);
        }
        .control-button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        #modal {
            transition: opacity 0.3s ease-in-out;
            pointer-events: auto;
        }
        #modal.hidden {
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="game-canvas"></canvas>

    <div class="ui-overlay">
        <!-- Titre et messages -->
        <header class="ui-panel text-center mt-4">
            <h1 class="text-3xl md:text-4xl font-black tracking-tighter text-transparent bg-clip-text bg-gradient-to-r from-sky-400 to-cyan-300">Bataille Navale 3D de RTN</h1>
            <p id="message-area" class="text-md md:text-lg text-slate-400 h-6 mt-1 transition-opacity duration-300"></p>
        </header>

        <!-- Panneau de contrôle -->
        <footer id="controls" class="ui-panel mb-4 flex items-center justify-center space-x-4">
            <button id="rotate-button" class="control-button bg-slate-700 hover:bg-slate-600 text-white font-bold py-2 px-4 rounded-lg shadow-lg">
                Pivoter (Horizontal)
            </button>
            <button id="start-button" class="control-button bg-sky-500 hover:bg-sky-400 text-white font-bold py-2 px-6 rounded-lg shadow-lg" disabled>
                Lancer la partie
            </button>
        </footer>
    </div>

    <!-- Modale de fin de partie -->
    <div id="modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
        <div class="bg-slate-800 rounded-lg shadow-2xl p-8 text-center max-w-sm mx-auto ui-panel">
            <h2 id="modal-title" class="text-4xl font-black mb-4"></h2>
            <p id="modal-message" class="text-slate-300 mb-6"></p>
            <button id="play-again-button" class="control-button bg-sky-500 hover:bg-sky-400 text-white font-bold py-3 px-6 rounded-lg w-full">
                Rejouer
            </button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- CONSTANTES ET VARIABLES GLOBALES ---
        const GRID_SIZE = 10;
        const CELL_SIZE = 2; // Taille de chaque cellule dans le monde 3D
        const SHIPS_CONFIG = [
            { name: 'Porte-avions', size: 5 },
            { name: 'Croiseur', size: 4 },
            { name: 'Contre-torpilleur', size: 3 },
            { name: 'Sous-marin', size: 3 },
            { name: 'Torpilleur', size: 2 }
        ];

        // Éléments UI
        const messageArea = document.getElementById('message-area');
        const rotateButton = document.getElementById('rotate-button');
        const startButton = document.getElementById('start-button');
        const modal = document.getElementById('modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const playAgainButton = document.getElementById('play-again-button');
        const canvas = document.getElementById('game-canvas');

        // Scène 3D
        let scene, camera, renderer, controls, raycaster;
        const mouse = new THREE.Vector2();
        let playerGridMeshes = [];
        let aiGridMeshes = [];
        let placementGhost; 
        let playerShipsGroup; 
        let hoverCellIndicator;
        // NEW: Liste pour gérer les animations actives
        let activeAnimations = [];

        // État du jeu
        let gameState = 'PLACEMENT'; // PLACEMENT, PLAYER_TURN, AI_TURN, GAME_OVER, ANIMATION
        let playerGridState = [];
        let aiGridState = [];
        let playerShips = [];
        let aiShips = [];
        let currentShipIndex = 0;
        let shipOrientation = 'horizontal';
        
        // NEW: Cerveau de l'IA pour le mode chasse/cible
        let aiBrain = {
            mode: 'hunt', // 'hunt' or 'target'
            lastHit: null,
            potentialTargets: []
        };

        // --- INITIALISATION ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0F172A);
            scene.fog = new THREE.Fog(0x0F172A, 100, 250);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, 40);
            
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            const ambientLight = new THREE.AmbientLight(0x607D8B, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(50, 50, 50);
            scene.add(directionalLight);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0);
            controls.enableDamping = true;
            controls.maxPolarAngle = Math.PI / 2 - 0.1;

            raycaster = new THREE.Raycaster();

            playerShipsGroup = new THREE.Group();
            scene.add(playerShipsGroup);

            const indicatorGeo = new THREE.PlaneGeometry(CELL_SIZE, CELL_SIZE);
            const indicatorMat = new THREE.MeshBasicMaterial({ color: 0x0EA5E9, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
            hoverCellIndicator = new THREE.Mesh(indicatorGeo, indicatorMat);
            hoverCellIndicator.rotation.x = -Math.PI / 2;
            hoverCellIndicator.visible = false;
            scene.add(hoverCellIndicator);

            window.addEventListener('resize', onWindowResize);
            
            initGame();
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // NEW: Mettre à jour les animations actives
            const now = performance.now();
            for (let i = activeAnimations.length - 1; i >= 0; i--) {
                if (activeAnimations[i].update(now)) {
                    activeAnimations.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- LOGIQUE DU JEU ---
        function initGame() {
            [...playerShipsGroup.children].forEach(c => playerShipsGroup.remove(c));
            playerGridMeshes.forEach(mesh => scene.remove(mesh));
            aiGridMeshes.forEach(mesh => scene.remove(mesh));
            if(placementGhost) scene.remove(placementGhost);
            
            // NEW: Nettoyer les marqueurs et projectiles
            const objectsToRemove = scene.children.filter(child => child.userData.isMarker || child.userData.isProjectile);
            objectsToRemove.forEach(obj => scene.remove(obj));

            gameState = 'PLACEMENT';
            playerGridState = createEmptyGrid();
            aiGridState = createEmptyGrid();
            playerShips = [];
            aiShips = [];
            currentShipIndex = 0;
            shipOrientation = 'horizontal';
            playerGridMeshes = [];
            aiGridMeshes = [];
            // NEW: Réinitialiser le cerveau de l'IA
            aiBrain = { mode: 'hunt', lastHit: null, potentialTargets: [] };

            create3DGrids();
            createPlacementGhost();

            updateMessage(`Placez votre ${SHIPS_CONFIG[currentShipIndex].name}.`);
            rotateButton.textContent = 'Pivoter (Horizontal)';
            rotateButton.disabled = false;
            startButton.disabled = true;
            modal.classList.add('hidden');

            addPlacementListeners();
            placeAiShips();
        }

        function createEmptyGrid() {
            return Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill({ type: 'empty', shipId: null }));
        }

        function create3DGrids() {
            const gridOffset = (GRID_SIZE * CELL_SIZE) / 2 - CELL_SIZE / 2;
            const playerGridZ = -25;
            const aiGridZ = 25;

            const playerGridMaterial = new THREE.MeshBasicMaterial({ color: 0x334155, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
            const gridGeometry = new THREE.PlaneGeometry(GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);
            const playerGridPlane = new THREE.Mesh(gridGeometry, playerGridMaterial);
            playerGridPlane.rotation.x = -Math.PI / 2;
            playerGridPlane.position.z = playerGridZ;
            scene.add(playerGridPlane);
            
            const aiGridMaterial = playerGridMaterial.clone();
            const aiGridPlane = new THREE.Mesh(gridGeometry, aiGridMaterial);
            aiGridPlane.rotation.x = -Math.PI / 2;
            aiGridPlane.position.z = aiGridZ;
            scene.add(aiGridPlane);

            const cellGeo = new THREE.PlaneGeometry(CELL_SIZE, CELL_SIZE);
            const transparentMat = new THREE.MeshBasicMaterial({ visible: false });
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const playerCell = new THREE.Mesh(cellGeo, transparentMat);
                    playerCell.position.set(x * CELL_SIZE - gridOffset, 0.1, y * CELL_SIZE - gridOffset + playerGridZ);
                    playerCell.rotation.x = -Math.PI / 2;
                    playerCell.userData = { x, y, owner: 'player' };
                    scene.add(playerCell);
                    playerGridMeshes.push(playerCell);

                    const aiCell = new THREE.Mesh(cellGeo, transparentMat);
                    aiCell.position.set(x * CELL_SIZE - gridOffset, 0.1, y * CELL_SIZE - gridOffset + aiGridZ);
                    aiCell.rotation.x = -Math.PI / 2;
                    aiCell.userData = { x, y, owner: 'ai' };
                    scene.add(aiCell);
                    aiGridMeshes.push(aiCell);
                }
            }
        }
        
        // --- PLACEMENT DES NAVIRES ---
        function createShipMesh(size, isGhost = false) {
            const shipGroup = new THREE.Group();
            const material = new THREE.MeshStandardMaterial({
                color: isGhost ? 0x0EA5E9 : 0x94A3B8,
                transparent: isGhost,
                opacity: 0.6
            });

            for (let i = 0; i < size; i++) {
                const geo = new THREE.BoxGeometry(CELL_SIZE * 0.8, CELL_SIZE * 0.8, CELL_SIZE * 0.8);
                const cube = new THREE.Mesh(geo, material);
                cube.position.z = i * CELL_SIZE - (size - 1) * CELL_SIZE / 2;
                shipGroup.add(cube);
            }
            return shipGroup;
        }

        function createPlacementGhost() {
            const shipConfig = SHIPS_CONFIG[currentShipIndex];
            placementGhost = createShipMesh(shipConfig.size, true);
            placementGhost.visible = false;
            scene.add(placementGhost);
        }

        function updatePlacementGhost(shipSize) {
            scene.remove(placementGhost);
            placementGhost = createShipMesh(shipSize, true);
            placementGhost.rotation.y = shipOrientation === 'horizontal' ? Math.PI / 2 : 0;
            scene.add(placementGhost);
        }

        function handlePlacementMouseMove(event) {
            if (gameState !== 'PLACEMENT') return;
            updateMouseRaycaster(event);
            const intersects = raycaster.intersectObjects(playerGridMeshes);
            if (intersects.length > 0) {
                const intersect = intersects[0];
                const { x, y } = intersect.object.userData;
                const shipConfig = SHIPS_CONFIG[currentShipIndex];
                
                const isValid = canPlaceShip(x, y, shipConfig.size, shipOrientation, playerGridState);
                placementGhost.position.copy(intersect.object.position);
                placementGhost.position.y = 0.5;
                
                 if (shipOrientation === 'horizontal') {
                    placementGhost.position.x += (shipConfig.size - 1) * CELL_SIZE / 2;
                } else {
                    placementGhost.position.z += (shipConfig.size - 1) * CELL_SIZE / 2;
                }

                placementGhost.children.forEach(child => {
                    child.material.color.set(isValid ? 0x0EA5E9 : 0xF43F5E);
                });
                placementGhost.visible = true;
            } else {
                placementGhost.visible = false;
            }
        }

        function handlePlacementClick(event) {
            if (gameState !== 'PLACEMENT' || !placementGhost.visible) return;
            updateMouseRaycaster(event);
            const intersects = raycaster.intersectObjects(playerGridMeshes);

            if (intersects.length > 0) {
                const { x, y } = intersects[0].object.userData;
                const shipConfig = SHIPS_CONFIG[currentShipIndex];

                if (canPlaceShip(x, y, shipConfig.size, shipOrientation, playerGridState)) {
                    placeShip(x, y, shipConfig, shipOrientation, playerGridState, playerShips, true);
                    
                    currentShipIndex++;
                    if (currentShipIndex >= SHIPS_CONFIG.length) {
                        gameState = 'READY';
                        updateMessage('Flotte déployée. Prêt au combat !');
                        removePlacementListeners();
                        scene.remove(placementGhost);
                        startButton.disabled = false;
                        rotateButton.disabled = true;
                    } else {
                        updateMessage(`Placez votre ${SHIPS_CONFIG[currentShipIndex].name}.`);
                        updatePlacementGhost(SHIPS_CONFIG[currentShipIndex].size);
                    }
                }
            }
        }

        function getShipCells(x, y, size, orientation) {
            const cells = [];
            for (let i = 0; i < size; i++) {
                if (orientation === 'horizontal') {
                    cells.push({ x: x + i, y: y });
                } else {
                    cells.push({ x: x, y: y + i });
                }
            }
            return cells;
        }

        function canPlaceShip(x, y, size, orientation, grid) {
            return getShipCells(x, y, size, orientation).every(cell =>
                cell.x >= 0 && cell.x < GRID_SIZE &&
                cell.y >= 0 && cell.y < GRID_SIZE &&
                grid[cell.y][cell.x].type === 'empty'
            );
        }

        function placeShip(x, y, shipConfig, orientation, grid, shipList, isPlayer = false) {
            const ship = {
                ...shipConfig,
                id: shipConfig.name + Math.random(),
                orientation,
                hits: 0,
                sunk: false
            };
            getShipCells(x, y, shipConfig.size, orientation).forEach(cell => {
                grid[cell.y][cell.x] = { type: 'ship', shipId: ship.id };
            });
            shipList.push(ship);
            
            if (isPlayer) {
                const shipMesh = createShipMesh(ship.size, false);
                shipMesh.rotation.y = orientation === 'horizontal' ? Math.PI / 2 : 0;
                const gridOffset = (GRID_SIZE * CELL_SIZE) / 2 - CELL_SIZE / 2;
                shipMesh.position.set(
                    (x + (orientation === 'horizontal' ? (ship.size-1)/2 : 0)) * CELL_SIZE - gridOffset,
                    0.5,
                    (y + (orientation === 'vertical' ? (ship.size-1)/2 : 0)) * CELL_SIZE - gridOffset - 25
                );
                playerShipsGroup.add(shipMesh);
            }
        }

        function placeAiShips() {
            SHIPS_CONFIG.forEach(shipConfig => {
                let placed = false;
                while (!placed) {
                    const orientation = Math.random() > 0.5 ? 'horizontal' : 'vertical';
                    const x = Math.floor(Math.random() * GRID_SIZE);
                    const y = Math.floor(Math.random() * GRID_SIZE);

                    if (canPlaceShip(x, y, shipConfig.size, orientation, aiGridState)) {
                        placeShip(x, y, shipConfig, orientation, aiGridState, aiShips, false);
                        placed = true;
                    }
                }
            });
        }
        
        // --- PHASE DE COMBAT ---

        function handleMouseMoveCombat(event) {
            if (gameState !== 'PLAYER_TURN') {
                hoverCellIndicator.visible = false;
                return;
            }
            updateMouseRaycaster(event);
            const intersects = raycaster.intersectObjects(aiGridMeshes);
             if (intersects.length > 0) {
                const cell = intersects[0].object;
                const {x, y} = cell.userData;
                if(aiGridState[y][x].type === 'empty') {
                    hoverCellIndicator.position.copy(cell.position);
                    hoverCellIndicator.position.y += 0.02;
                    hoverCellIndicator.visible = true;
                } else {
                    hoverCellIndicator.visible = false;
                }
            } else {
                hoverCellIndicator.visible = false;
            }
        }

        function handlePlayerFire(event) {
            if (gameState !== 'PLAYER_TURN' || event.target.tagName !== 'CANVAS') return;
            updateMouseRaycaster(event);
            const intersects = raycaster.intersectObjects(aiGridMeshes);
            if (intersects.length > 0) {
                const { x, y } = intersects[0].object.userData;
                const cellState = aiGridState[y][x];

                if (cellState.type === 'hit' || cellState.type === 'miss') return;

                // NEW: Lancer l'animation de projectile
                gameState = 'ANIMATION';
                fireProjectile(intersects[0].object.position, () => {
                    processShot(x, y, aiGridState, aiShips, intersects[0].object.position);
                    checkGameOver();
                    if (gameState !== 'GAME_OVER') {
                        gameState = 'AI_TURN';
                        updateMessage("L'ennemi réfléchit...");
                        setTimeout(aiTurn, 1500);
                    }
                });
            }
        }

        function aiTurn() {
            if(gameState !== 'AI_TURN') return;
            // NEW: L'IA utilise son cerveau pour choisir une cible
            const { x, y } = getAiTarget();
            
            updateMessage(`L'ennemi tire en ${String.fromCharCode(65 + x)}${y + 1}...`);
            const cellMesh = playerGridMeshes.find(m => m.userData.x === x && m.userData.y === y);
            
            // NEW: Lancer l'animation de projectile pour l'IA
            gameState = 'ANIMATION';
            fireProjectile(cellMesh.position, () => {
                processShot(x, y, playerGridState, playerShips, cellMesh.position, true); // isAIShot = true
                checkGameOver();
                if (gameState !== 'GAME_OVER') {
                    gameState = 'PLAYER_TURN';
                    updateMessage('À votre tour !');
                }
            }, true); // isAI = true
        }

        // NEW: Logique de l'IA améliorée
        function getAiTarget() {
            // Si en mode 'cible' et qu'il y a des cibles potentielles, en choisir une
            if (aiBrain.mode === 'target' && aiBrain.potentialTargets.length > 0) {
                return aiBrain.potentialTargets.pop();
            }
            
            // Sinon, mode 'chasse'
            let x, y;
            do {
                x = Math.floor(Math.random() * GRID_SIZE);
                y = Math.floor(Math.random() * GRID_SIZE);
            } while (playerGridState[y][x].type === 'hit' || playerGridState[y][x].type === 'miss');
            return { x, y };
        }

        function updatePotentialTargets(hit) {
            const { x, y } = hit;
            const neighbors = [{x:x-1,y},{x:x+1,y},{x,y:y-1},{x,y:y+1}];
            
            neighbors.forEach(n => {
                // Si la case est valide et n'a pas été touchée
                if (n.x >= 0 && n.x < GRID_SIZE && n.y >= 0 && n.y < GRID_SIZE && playerGridState[n.y][n.x].type === 'empty') {
                    // Éviter les doublons
                    if (!aiBrain.potentialTargets.some(t => t.x === n.x && t.y === n.y)) {
                       aiBrain.potentialTargets.push(n);
                    }
                }
            });
        }

        function processShot(x, y, grid, shipList, position, isAIShot = false) {
            const cell = grid[y][x];
            if (cell.type === 'ship') {
                grid[y][x].type = 'hit';
                createHitMarker(position);
                const ship = shipList.find(s => s.id === cell.shipId);
                ship.hits++;

                // NEW: Gérer la logique de l'IA après un tir réussi
                if (isAIShot) {
                    aiBrain.mode = 'target';
                    aiBrain.lastHit = { x, y };
                    updatePotentialTargets({ x, y });
                }

                if (ship.hits === ship.size) {
                    ship.sunk = true;
                    updateMessage(`Un ${ship.name} a été coulé !`);
                    // NEW: Si un navire est coulé, l'IA retourne en mode chasse
                    if (isAIShot) {
                        aiBrain.mode = 'hunt';
                        aiBrain.potentialTargets = [];
                    }
                }
            } else {
                grid[y][x].type = 'miss';
                createMissMarker(position);
                 // NEW: Si l'IA manque son tir en mode cible, elle retire cette cible
                if (isAIShot && aiBrain.mode === 'target') {
                    aiBrain.potentialTargets = aiBrain.potentialTargets.filter(t => t.x !== x || t.y !== y);
                }
            }
        }
        
        // --- NOUVEAUX EFFETS VISUELS ---

        function fireProjectile(targetPosition, onComplete, isAI = false) {
            const startPosition = new THREE.Vector3(0, 10, isAI ? 40 : -40);
            const controlPoint = new THREE.Vector3(
                (startPosition.x + targetPosition.x) / 2,
                60,
                (startPosition.z + targetPosition.z) / 2
            );
            const curve = new THREE.QuadraticBezierCurve3(startPosition, controlPoint, targetPosition);

            const geo = new THREE.SphereGeometry(0.3, 16, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffa500 });
            const projectile = new THREE.Mesh(geo, mat);
            projectile.userData.isProjectile = true;
            scene.add(projectile);

            const animation = {
                startTime: performance.now(),
                duration: 1000,
                update: (now) => {
                    const elapsed = now - animation.startTime;
                    const t = Math.min(1, elapsed / animation.duration);
                    projectile.position.copy(curve.getPoint(t));
                    if (t >= 1) {
                        scene.remove(projectile);
                        onComplete();
                        return true; // Animation terminée
                    }
                    return false;
                }
            };
            activeAnimations.push(animation);
        }

        function createHitMarker(position) {
            const geo = new THREE.SphereGeometry(CELL_SIZE / 4, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: 0xF43F5E });
            const marker = new THREE.Mesh(geo, mat);
            marker.position.copy(position);
            marker.position.y = 0.5;
            marker.scale.set(0.1, 0.1, 0.1);
            marker.userData.isMarker = true;
            scene.add(marker);

            // Effet d'explosion et tremblement
            const light = new THREE.PointLight(0xF43F5E, 5, 20);
            light.position.copy(marker.position);
            scene.add(light);
            setTimeout(() => scene.remove(light), 300);
            shakeCamera(0.2, 200);

            // Animation d'apparition
            animateScale(marker, new THREE.Vector3(1, 1, 1), 200);
        }

        function createMissMarker(position) {
            // Remplacer la sphère par une gerbe de particules
            for (let i = 0; i < 20; i++) {
                const pGeo = new THREE.SphereGeometry(0.1, 4, 4);
                const pMat = new THREE.MeshBasicMaterial({ color: 0xcccccc, transparent: true });
                const particle = new THREE.Mesh(pGeo, pMat);
                particle.position.copy(position);
                particle.userData.isMarker = true;

                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 3,
                    Math.random() * 5 + 2,
                    (Math.random() - 0.5) * 3
                );
                
                const particleAnimation = {
                    startTime: performance.now(),
                    duration: 800,
                    update: (now) => {
                        const elapsed = (now - particleAnimation.startTime) / 1000;
                        if (elapsed * 1000 > particleAnimation.duration) {
                            scene.remove(particle);
                            return true;
                        }
                        velocity.y -= 9.8 * 0.02; // Gravité
                        particle.position.addScaledVector(velocity, 0.01);
                        particle.material.opacity = 1.0 - (elapsed * 1000 / particleAnimation.duration);
                        return false;
                    }
                };
                activeAnimations.push(particleAnimation);
                scene.add(particle);
            }
        }

        function shakeCamera(intensity, duration) {
            const startPos = camera.position.clone();
            const shake = {
                startTime: performance.now(),
                duration: duration,
                update: (now) => {
                    const elapsed = now - shake.startTime;
                    if (elapsed > shake.duration) {
                        camera.position.copy(startPos);
                        return true;
                    }
                    const percent = 1 - (elapsed / shake.duration);
                    const displacement = intensity * percent;
                    camera.position.x = startPos.x + (Math.random() - 0.5) * displacement;
                    camera.position.y = startPos.y + (Math.random() - 0.5) * displacement;
                    return false;
                }
            };
            activeAnimations.push(shake);
        }

        function animateScale(object, targetScale, duration) {
            const startScale = object.scale.clone();
            const scaleAnim = {
                startTime: performance.now(),
                duration: duration,
                update: (now) => {
                    const elapsed = now - scaleAnim.startTime;
                    const t = Math.min(1, elapsed / duration);
                    object.scale.lerpVectors(startScale, targetScale, t);
                    return t >= 1;
                }
            };
            activeAnimations.push(scaleAnim);
        }
        
        function checkGameOver() {
            if (aiShips.every(s => s.sunk)) {
                endGame(true);
            } else if (playerShips.every(s => s.sunk)) {
                endGame(false);
            }
        }

        function endGame(playerWon) {
            gameState = 'GAME_OVER';
            removeCombatListeners();
            modalTitle.textContent = playerWon ? "Victoire !" : "Défaite...";
            modalMessage.textContent = playerWon ? "Vous avez anéanti la flotte ennemie !" : "Votre flotte a été détruite.";
            modalTitle.className = `text-4xl font-black mb-4 ${playerWon ? 'text-sky-400' : 'text-rose-500'}`;
            modal.classList.remove('hidden');
        }

        // --- UTILITAIRES & ÉVÉNEMENTS ---
        function updateMessage(msg) {
            messageArea.style.opacity = '0';
            setTimeout(() => {
                messageArea.textContent = msg;
                messageArea.style.opacity = '1';
            }, 300);
        }

        function updateMouseRaycaster(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
        }

        function addPlacementListeners() {
            window.addEventListener('mousemove', handlePlacementMouseMove);
            window.addEventListener('mousedown', handlePlacementClick);
        }

        function removePlacementListeners() {
            window.removeEventListener('mousemove', handlePlacementMouseMove);
            window.removeEventListener('mousedown', handlePlacementClick);
        }

        function addCombatListeners() {
            window.addEventListener('mousemove', handleMouseMoveCombat);
            window.addEventListener('mousedown', handlePlayerFire);
        }

        function removeCombatListeners() {
             window.removeEventListener('mousemove', handleMouseMoveCombat);
            window.removeEventListener('mousedown', handlePlayerFire);
        }

        function startGame() {
            gameState = 'PLAYER_TURN';
            updateMessage('À votre tour ! Tirez sur la zone ennemie.');
            startButton.disabled = true;
            addCombatListeners();
        }

        rotateButton.addEventListener('click', () => {
            if (gameState === 'PLACEMENT') {
                shipOrientation = shipOrientation === 'horizontal' ? 'vertical' : 'horizontal';
                rotateButton.textContent = `Pivoter (${shipOrientation === 'horizontal' ? 'Horizontal' : 'Vertical'})`;
                updatePlacementGhost(SHIPS_CONFIG[currentShipIndex].size);
            }
        });

        startButton.addEventListener('click', () => {
            if (gameState === 'READY') {
                startGame();
            }
        });

        playAgainButton.addEventListener('click', initGame);

        // --- DÉMARRAGE ---
        init();
    </script>
</body>
</html>

